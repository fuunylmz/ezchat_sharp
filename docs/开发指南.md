# EzChat Sharp - 开发指南

## 开发环境搭建

### 前置要求
- .NET 9.0 SDK
- Visual Studio 2022 或 VS Code
- Git (版本控制)

### 项目初始化
```bash
# 克隆项目
git clone <repository-url>
cd ezchat_sharp

# 还原依赖
dotnet restore

# 构建项目
dotnet build
```

## 项目结构规划

```
ezchat_sharp/
├── src/
│   ├── Server/                 # 服务器端代码
│   │   ├── ChatServer.cs       # 主服务器类
│   │   ├── Models/             # 数据模型
│   │   │   ├── User.cs
│   │   │   ├── ChatMessage.cs
│   │   │   ├── ChatRoom.cs
│   │   │   └── MessageType.cs
│   │   ├── Managers/           # 管理器类
│   │   │   ├── ClientSessionManager.cs
│   │   │   ├── ChatRoomManager.cs
│   │   │   └── MessageHandler.cs
│   │   ├── Network/            # 网络通信
│   │   │   ├── TcpServer.cs
│   │   │   └── ClientSession.cs
│   │   └── Utils/              # 工具类
│   │       ├── JsonSerializer.cs
│   │       └── Logger.cs
│   ├── Client/                 # 客户端代码
│   │   ├── ChatClient.cs       # 主客户端类
│   │   ├── Network/            # 网络通信
│   │   │   └── NetworkManager.cs
│   │   ├── UI/                 # 用户界面
│   │   │   ├── UIManager.cs
│   │   │   ├── CommandParser.cs
│   │   │   └── MessageFormatter.cs
│   │   └── Utils/              # 工具类
│   │       └── MessageQueue.cs
│   ├── Shared/                 # 共享代码
│   │   ├── Models/             # 共享数据模型
│   │   ├── Constants/          # 常量定义
│   │   └── Extensions/         # 扩展方法
│   └── Program.cs              # 程序入口
├── tests/                      # 测试代码
│   ├── Server.Tests/
│   ├── Client.Tests/
│   └── Integration.Tests/
├── docs/                       # 文档
├── configs/                    # 配置文件
└── scripts/                    # 构建脚本
```

## 开发阶段规划

### 第一阶段：基础框架搭建

#### 1.1 创建基础项目结构
- 创建服务器和客户端项目
- 设置基础的依赖注入
- 配置日志系统

#### 1.2 定义数据模型
```csharp
// Models/User.cs
public class User
{
    public string UserId { get; set; } = string.Empty;
    public string Username { get; set; } = string.Empty;
    public DateTime ConnectedAt { get; set; }
    public string CurrentRoom { get; set; } = "general";
    public bool IsOnline { get; set; }
}

// Models/ChatMessage.cs
public class ChatMessage
{
    public string MessageId { get; set; } = Guid.NewGuid().ToString();
    public string SenderId { get; set; } = string.Empty;
    public string SenderName { get; set; } = string.Empty;
    public string Content { get; set; } = string.Empty;
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;
    public MessageType Type { get; set; }
    public string TargetRoom { get; set; } = "general";
}

// Models/MessageType.cs
public enum MessageType
{
    // 客户端到服务器
    Login,
    Logout,
    JoinRoom,
    LeaveRoom,
    SendMessage,
    ListRooms,
    ListUsers,
    CreateRoom,
    
    // 服务器到客户端
    LoginSuccess,
    LoginFailed,
    MessageReceived,
    UserJoined,
    UserLeft,
    RoomList,
    UserList,
    Error,
    ServerShutdown
}
```

#### 1.3 实现基础网络通信
```csharp
// Network/TcpServer.cs
public class TcpServer
{
    private TcpListener _listener;
    private CancellationTokenSource _cancellationTokenSource;
    private readonly ILogger<TcpServer> _logger;
    
    public event Action<TcpClient> ClientConnected;
    
    public async Task StartAsync(IPEndPoint endPoint)
    {
        _listener = new TcpListener(endPoint);
        _listener.Start();
        
        _logger.LogInformation("Server started on {EndPoint}", endPoint);
        
        while (!_cancellationTokenSource.Token.IsCancellationRequested)
        {
            var tcpClient = await _listener.AcceptTcpClientAsync();
            ClientConnected?.Invoke(tcpClient);
        }
    }
}
```

### 第二阶段：核心功能实现

#### 2.1 服务器端核心功能
- 客户端连接管理
- 消息路由和转发
- 聊天室管理
- 用户状态管理

#### 2.2 客户端核心功能
- 服务器连接
- 用户界面
- 消息收发
- 命令解析

#### 2.3 消息协议实现
```csharp
// 消息序列化示例
public static class MessageSerializer
{
    public static string Serialize<T>(T message)
    {
        return JsonSerializer.Serialize(message, new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        });
    }
    
    public static T Deserialize<T>(string json)
    {
        return JsonSerializer.Deserialize<T>(json, new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        });
    }
}
```

### 第三阶段：功能完善

#### 3.1 错误处理和异常管理
- 网络异常处理
- 业务逻辑异常
- 用户输入验证

#### 3.2 性能优化
- 异步编程优化
- 内存使用优化
- 网络传输优化

#### 3.3 用户体验改进
- 命令行界面美化
- 消息格式化
- 状态提示

### 第四阶段：测试和部署

#### 4.1 单元测试
```csharp
[Test]
public async Task ChatServer_ShouldAcceptClientConnection()
{
    // Arrange
    var server = new ChatServer();
    var client = new TcpClient();
    
    // Act
    await server.StartAsync(new IPEndPoint(IPAddress.Loopback, 8080));
    await client.ConnectAsync(IPAddress.Loopback, 8080);
    
    // Assert
    Assert.IsTrue(client.Connected);
}
```

#### 4.2 集成测试
- 多客户端连接测试
- 消息传递测试
- 并发性能测试

## 开发最佳实践

### 代码规范

#### 命名约定
- 类名：PascalCase (例：`ChatServer`)
- 方法名：PascalCase (例：`SendMessage`)
- 变量名：camelCase (例：`userName`)
- 常量：UPPER_CASE (例：`MAX_MESSAGE_LENGTH`)
- 私有字段：_camelCase (例：`_logger`)

#### 代码组织
```csharp
// 好的示例
public class ChatServer
{
    // 1. 常量
    private const int DEFAULT_PORT = 8080;
    
    // 2. 私有字段
    private readonly ILogger<ChatServer> _logger;
    private readonly ClientSessionManager _sessionManager;
    
    // 3. 构造函数
    public ChatServer(ILogger<ChatServer> logger)
    {
        _logger = logger;
        _sessionManager = new ClientSessionManager();
    }
    
    // 4. 公共属性
    public bool IsRunning { get; private set; }
    
    // 5. 公共方法
    public async Task StartAsync()
    {
        // 实现
    }
    
    // 6. 私有方法
    private async Task HandleClientAsync(TcpClient client)
    {
        // 实现
    }
}
```

### 异步编程指南

#### 正确使用 async/await
```csharp
// 好的示例
public async Task<bool> SendMessageAsync(ChatMessage message)
{
    try
    {
        var json = MessageSerializer.Serialize(message);
        var buffer = Encoding.UTF8.GetBytes(json);
        await _networkStream.WriteAsync(buffer, 0, buffer.Length);
        return true;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Failed to send message");
        return false;
    }
}

// 避免的示例
public bool SendMessage(ChatMessage message)
{
    // 不要在同步方法中调用 .Result
    return SendMessageAsync(message).Result;
}
```

#### 取消令牌使用
```csharp
public async Task ProcessMessagesAsync(CancellationToken cancellationToken)
{
    while (!cancellationToken.IsCancellationRequested)
    {
        try
        {
            var message = await ReceiveMessageAsync(cancellationToken);
            await ProcessMessageAsync(message, cancellationToken);
        }
        catch (OperationCanceledException)
        {
            _logger.LogInformation("Message processing cancelled");
            break;
        }
    }
}
```

### 错误处理策略

#### 分层异常处理
```csharp
// 网络层
public class NetworkManager
{
    public async Task<string> ReceiveMessageAsync()
    {
        try
        {
            // 网络操作
        }
        catch (SocketException ex)
        {
            throw new NetworkException("Network communication failed", ex);
        }
    }
}

// 业务层
public class MessageHandler
{
    public async Task HandleMessageAsync(string rawMessage)
    {
        try
        {
            var message = MessageSerializer.Deserialize<ChatMessage>(rawMessage);
            await ProcessMessageAsync(message);
        }
        catch (JsonException ex)
        {
            throw new MessageFormatException("Invalid message format", ex);
        }
        catch (NetworkException ex)
        {
            _logger.LogError(ex, "Network error while handling message");
            // 重试逻辑或降级处理
        }
    }
}
```

### 日志记录指南

#### 结构化日志
```csharp
public class ChatServer
{
    private readonly ILogger<ChatServer> _logger;
    
    public async Task HandleClientConnectionAsync(string clientId, string userName)
    {
        _logger.LogInformation(
            "Client connected: {ClientId} with username {UserName}",
            clientId, userName);
            
        try
        {
            // 处理逻辑
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, 
                "Error handling client {ClientId}", clientId);
        }
    }
}
```

#### 日志级别使用
- **Debug**: 详细的调试信息
- **Information**: 一般信息（用户连接、消息发送等）
- **Warning**: 警告信息（重试、降级等）
- **Error**: 错误信息（异常、失败等）
- **Critical**: 严重错误（服务器崩溃等）

## 调试技巧

### 网络调试
```csharp
// 添加网络流量日志
public class LoggingNetworkStream : NetworkStream
{
    private readonly ILogger _logger;
    
    public override async Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
    {
        _logger.LogDebug("Sending {Count} bytes: {Data}", 
            count, Encoding.UTF8.GetString(buffer, offset, count));
        await base.WriteAsync(buffer, offset, count, cancellationToken);
    }
}
```

### 消息追踪
```csharp
public class ChatMessage
{
    public string MessageId { get; set; } = Guid.NewGuid().ToString();
    public string TraceId { get; set; } = Activity.Current?.Id ?? Guid.NewGuid().ToString();
    // 其他属性...
}
```

## 性能监控

### 关键指标
- 并发连接数
- 消息处理延迟
- 内存使用量
- CPU 使用率
- 网络吞吐量

### 监控实现
```csharp
public class PerformanceMetrics
{
    private static readonly Counter MessagesSent = Metrics
        .CreateCounter("chat_messages_sent_total", "Total messages sent");
        
    private static readonly Histogram MessageProcessingTime = Metrics
        .CreateHistogram("chat_message_processing_seconds", "Message processing time");
        
    public static void RecordMessageSent()
    {
        MessagesSent.Inc();
    }
    
    public static void RecordMessageProcessingTime(double seconds)
    {
        MessageProcessingTime.Observe(seconds);
    }
}
```

## 部署指南

### 开发环境部署
```bash
# 启动服务器
dotnet run --project src/Server

# 启动客户端（新终端）
dotnet run --project src/Client
```

### 生产环境部署
```bash
# 发布应用
dotnet publish -c Release -o ./publish

# 运行服务器
./publish/EzChatSharp.Server

# 运行客户端
./publish/EzChatSharp.Client
```

### 配置管理
```json
// appsettings.json
{
  "Server": {
    "Port": 8080,
    "MaxConnections": 100,
    "MessageBufferSize": 1024
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "EzChatSharp": "Debug"
    }
  }
}
```

---

*本开发指南将随着项目进展持续更新和完善*