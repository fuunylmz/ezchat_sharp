# EzChat Sharp - 测试计划文档

## 测试概述

### 测试目标
- 确保聊天服务器的稳定性和可靠性
- 验证客户端-服务器通信的正确性
- 测试并发场景下的系统性能
- 验证错误处理和异常恢复机制
- 确保用户体验的流畅性

### 测试策略
- **单元测试**: 测试独立组件和方法
- **集成测试**: 测试组件间的交互
- **系统测试**: 测试完整的端到端功能
- **性能测试**: 测试系统在负载下的表现
- **压力测试**: 测试系统的极限承受能力

## 测试环境搭建

### 开发环境
```bash
# 安装测试框架
dotnet add package Microsoft.NET.Test.Sdk
dotnet add package NUnit
dotnet add package NUnit3TestAdapter
dotnet add package Moq
dotnet add package FluentAssertions

# 性能测试工具
dotnet add package BenchmarkDotNet
dotnet add package NBomber
```

### 测试项目结构
```
tests/
├── EzChatSharp.UnitTests/
│   ├── Server/
│   │   ├── ChatServerTests.cs
│   │   ├── MessageHandlerTests.cs
│   │   ├── ClientSessionManagerTests.cs
│   │   └── ChatRoomManagerTests.cs
│   ├── Client/
│   │   ├── ChatClientTests.cs
│   │   ├── NetworkManagerTests.cs
│   │   └── UIManagerTests.cs
│   ├── Shared/
│   │   ├── MessageSerializerTests.cs
│   │   └── ValidationTests.cs
│   └── TestHelpers/
│       ├── MockTcpClient.cs
│       ├── TestDataBuilder.cs
│       └── TestConstants.cs
├── EzChatSharp.IntegrationTests/
│   ├── ServerClientIntegrationTests.cs
│   ├── MultiClientTests.cs
│   ├── RoomManagementTests.cs
│   └── MessageFlowTests.cs
├── EzChatSharp.PerformanceTests/
│   ├── ConcurrencyTests.cs
│   ├── LoadTests.cs
│   ├── MemoryTests.cs
│   └── NetworkTests.cs
└── EzChatSharp.E2ETests/
    ├── ChatScenarioTests.cs
    ├── UserJourneyTests.cs
    └── ErrorRecoveryTests.cs
```

## 单元测试计划

### 1. 服务器端单元测试

#### 1.1 ChatServer 测试
```csharp
[TestFixture]
public class ChatServerTests
{
    private ChatServer _chatServer;
    private Mock<ILogger<ChatServer>> _mockLogger;
    private Mock<IDataStore> _mockDataStore;
    
    [SetUp]
    public void Setup()
    {
        _mockLogger = new Mock<ILogger<ChatServer>>();
        _mockDataStore = new Mock<IDataStore>();
        _chatServer = new ChatServer(_mockLogger.Object, _mockDataStore.Object);
    }
    
    [Test]
    public async Task StartAsync_ShouldStartListening_WhenValidPortProvided()
    {
        // Arrange
        var port = 8080;
        
        // Act
        await _chatServer.StartAsync(port);
        
        // Assert
        _chatServer.IsRunning.Should().BeTrue();
    }
    
    [Test]
    public async Task StartAsync_ShouldThrowException_WhenPortInUse()
    {
        // Arrange
        var port = 8080;
        await _chatServer.StartAsync(port);
        var secondServer = new ChatServer(_mockLogger.Object, _mockDataStore.Object);
        
        // Act & Assert
        await secondServer.Invoking(s => s.StartAsync(port))
            .Should().ThrowAsync<SocketException>();
    }
    
    [Test]
    public async Task HandleClientAsync_ShouldCreateSession_WhenClientConnects()
    {
        // Arrange
        var mockTcpClient = new MockTcpClient();
        
        // Act
        await _chatServer.HandleClientAsync(mockTcpClient);
        
        // Assert
        _mockDataStore.Verify(ds => ds.AddSessionAsync(It.IsAny<ClientSession>()), Times.Once);
    }
}
```

#### 1.2 MessageHandler 测试
```csharp
[TestFixture]
public class MessageHandlerTests
{
    private MessageHandler _messageHandler;
    private Mock<IDataStore> _mockDataStore;
    private Mock<IClientSessionManager> _mockSessionManager;
    
    [Test]
    public async Task HandleLoginMessage_ShouldReturnSuccess_WhenValidCredentials()
    {
        // Arrange
        var loginMessage = TestDataBuilder.CreateLoginMessage("testuser");
        var session = TestDataBuilder.CreateClientSession();
        
        _mockDataStore.Setup(ds => ds.GetUserByUsernameAsync("testuser"))
            .ReturnsAsync((User)null);
        
        // Act
        var result = await _messageHandler.HandleMessageAsync(loginMessage, session);
        
        // Assert
        result.Type.Should().Be(MessageType.LoginSuccess);
        _mockDataStore.Verify(ds => ds.AddUserAsync(It.IsAny<User>()), Times.Once);
    }
    
    [Test]
    public async Task HandleLoginMessage_ShouldReturnFailure_WhenUsernameTaken()
    {
        // Arrange
        var loginMessage = TestDataBuilder.CreateLoginMessage("existinguser");
        var session = TestDataBuilder.CreateClientSession();
        var existingUser = TestDataBuilder.CreateUser("existinguser");
        
        _mockDataStore.Setup(ds => ds.GetUserByUsernameAsync("existinguser"))
            .ReturnsAsync(existingUser);
        
        // Act
        var result = await _messageHandler.HandleMessageAsync(loginMessage, session);
        
        // Assert
        result.Type.Should().Be(MessageType.LoginFailed);
        result.Data.Should().Contain("USERNAME_TAKEN");
    }
    
    [Test]
    public async Task HandleSendMessage_ShouldBroadcastToRoom_WhenValidMessage()
    {
        // Arrange
        var sendMessage = TestDataBuilder.CreateSendMessage("Hello, World!", "general");
        var session = TestDataBuilder.CreateAuthenticatedSession();
        var roomMembers = TestDataBuilder.CreateRoomMembers(5);
        
        _mockDataStore.Setup(ds => ds.GetRoomUsersAsync("general"))
            .ReturnsAsync(roomMembers);
        
        // Act
        await _messageHandler.HandleMessageAsync(sendMessage, session);
        
        // Assert
        _mockSessionManager.Verify(sm => 
            sm.BroadcastToRoomAsync("general", It.IsAny<ChatMessage>()), Times.Once);
    }
}
```

#### 1.3 ClientSessionManager 测试
```csharp
[TestFixture]
public class ClientSessionManagerTests
{
    private ClientSessionManager _sessionManager;
    private Mock<IDataStore> _mockDataStore;
    
    [Test]
    public async Task AddSessionAsync_ShouldStoreSession_WhenValidSession()
    {
        // Arrange
        var session = TestDataBuilder.CreateClientSession();
        
        // Act
        var result = await _sessionManager.AddSessionAsync(session);
        
        // Assert
        result.Should().BeTrue();
        _mockDataStore.Verify(ds => ds.AddSessionAsync(session), Times.Once);
    }
    
    [Test]
    public async Task BroadcastToRoomAsync_ShouldSendToAllMembers_WhenRoomExists()
    {
        // Arrange
        var message = TestDataBuilder.CreateChatMessage();
        var roomMembers = TestDataBuilder.CreateRoomMembers(3);
        var sessions = TestDataBuilder.CreateSessionsForUsers(roomMembers);
        
        _mockDataStore.Setup(ds => ds.GetRoomUsersAsync("general"))
            .ReturnsAsync(roomMembers);
        
        foreach (var user in roomMembers)
        {
            _mockDataStore.Setup(ds => ds.GetUserSessionAsync(user.UserId))
                .ReturnsAsync(sessions[user.UserId]);
        }
        
        // Act
        await _sessionManager.BroadcastToRoomAsync("general", message);
        
        // Assert
        // 验证消息发送到所有会话
        foreach (var session in sessions.Values)
        {
            session.MockNetworkStream.Verify(ns => 
                ns.WriteAsync(It.IsAny<byte[]>(), 0, It.IsAny<int>()), Times.Once);
        }
    }
}
```

### 2. 客户端单元测试

#### 2.1 ChatClient 测试
```csharp
[TestFixture]
public class ChatClientTests
{
    private ChatClient _chatClient;
    private Mock<INetworkManager> _mockNetworkManager;
    private Mock<IUIManager> _mockUIManager;
    
    [Test]
    public async Task ConnectAsync_ShouldEstablishConnection_WhenServerAvailable()
    {
        // Arrange
        var serverEndpoint = new IPEndPoint(IPAddress.Loopback, 8080);
        _mockNetworkManager.Setup(nm => nm.ConnectAsync(serverEndpoint))
            .ReturnsAsync(true);
        
        // Act
        var result = await _chatClient.ConnectAsync(serverEndpoint);
        
        // Assert
        result.Should().BeTrue();
        _chatClient.IsConnected.Should().BeTrue();
    }
    
    [Test]
    public async Task LoginAsync_ShouldSendLoginMessage_WhenConnected()
    {
        // Arrange
        await _chatClient.ConnectAsync(new IPEndPoint(IPAddress.Loopback, 8080));
        var username = "testuser";
        
        _mockNetworkManager.Setup(nm => nm.SendMessageAsync(It.IsAny<ChatMessage>()))
            .ReturnsAsync(true);
        
        // Act
        await _chatClient.LoginAsync(username);
        
        // Assert
        _mockNetworkManager.Verify(nm => 
            nm.SendMessageAsync(It.Is<ChatMessage>(m => 
                m.Type == MessageType.Login && 
                m.Data.Contains(username))), Times.Once);
    }
}
```

#### 2.2 NetworkManager 测试
```csharp
[TestFixture]
public class NetworkManagerTests
{
    private NetworkManager _networkManager;
    private Mock<TcpClient> _mockTcpClient;
    private Mock<NetworkStream> _mockNetworkStream;
    
    [Test]
    public async Task SendMessageAsync_ShouldSerializeAndSend_WhenValidMessage()
    {
        // Arrange
        var message = TestDataBuilder.CreateChatMessage();
        var expectedBytes = Encoding.UTF8.GetBytes(JsonSerializer.Serialize(message));
        
        _mockNetworkStream.Setup(ns => ns.WriteAsync(
            It.IsAny<byte[]>(), 0, expectedBytes.Length))
            .Returns(Task.CompletedTask);
        
        // Act
        var result = await _networkManager.SendMessageAsync(message);
        
        // Assert
        result.Should().BeTrue();
        _mockNetworkStream.Verify(ns => 
            ns.WriteAsync(It.IsAny<byte[]>(), 0, expectedBytes.Length), Times.Once);
    }
    
    [Test]
    public async Task ReceiveMessageAsync_ShouldDeserializeMessage_WhenValidData()
    {
        // Arrange
        var originalMessage = TestDataBuilder.CreateChatMessage();
        var messageJson = JsonSerializer.Serialize(originalMessage);
        var messageBytes = Encoding.UTF8.GetBytes(messageJson);
        
        _mockNetworkStream.Setup(ns => ns.ReadAsync(
            It.IsAny<byte[]>(), 0, It.IsAny<int>()))
            .ReturnsAsync(messageBytes.Length)
            .Callback<byte[], int, int>((buffer, offset, count) => 
                Array.Copy(messageBytes, 0, buffer, offset, messageBytes.Length));
        
        // Act
        var receivedMessage = await _networkManager.ReceiveMessageAsync();
        
        // Assert
        receivedMessage.Should().NotBeNull();
        receivedMessage.MessageId.Should().Be(originalMessage.MessageId);
        receivedMessage.Content.Should().Be(originalMessage.Content);
    }
}
```

## 集成测试计划

### 1. 服务器-客户端集成测试

```csharp
[TestFixture]
public class ServerClientIntegrationTests
{
    private ChatServer _server;
    private ChatClient _client;
    private int _testPort = 9000;
    
    [SetUp]
    public async Task Setup()
    {
        _server = new ChatServer();
        await _server.StartAsync(_testPort);
        
        _client = new ChatClient();
        await _client.ConnectAsync(new IPEndPoint(IPAddress.Loopback, _testPort));
    }
    
    [TearDown]
    public async Task TearDown()
    {
        await _client.DisconnectAsync();
        await _server.StopAsync();
    }
    
    [Test]
    public async Task LoginFlow_ShouldCompleteSuccessfully_WhenValidUsername()
    {
        // Arrange
        var username = "integrationtestuser";
        
        // Act
        var loginResult = await _client.LoginAsync(username);
        
        // Assert
        loginResult.Should().BeTrue();
        _client.IsAuthenticated.Should().BeTrue();
        _client.CurrentUser.Username.Should().Be(username);
    }
    
    [Test]
    public async Task MessageFlow_ShouldDeliverMessage_WhenSentToRoom()
    {
        // Arrange
        await _client.LoginAsync("sender");
        await _client.JoinRoomAsync("testroom");
        
        var receivedMessages = new List<ChatMessage>();
        _client.MessageReceived += (sender, message) => receivedMessages.Add(message);
        
        // Act
        await _client.SendMessageAsync("Hello, Integration Test!", "testroom");
        await Task.Delay(100); // 等待消息传递
        
        // Assert
        receivedMessages.Should().HaveCount(1);
        receivedMessages[0].Content.Should().Be("Hello, Integration Test!");
        receivedMessages[0].SenderName.Should().Be("sender");
    }
}
```

### 2. 多客户端集成测试

```csharp
[TestFixture]
public class MultiClientIntegrationTests
{
    private ChatServer _server;
    private List<ChatClient> _clients;
    private int _testPort = 9001;
    
    [Test]
    public async Task MultipleClients_ShouldReceiveMessages_WhenBroadcastToRoom()
    {
        // Arrange
        const int clientCount = 5;
        _clients = new List<ChatClient>();
        var receivedMessages = new ConcurrentBag<(string clientName, ChatMessage message)>();
        
        // 创建多个客户端
        for (int i = 0; i < clientCount; i++)
        {
            var client = new ChatClient();
            await client.ConnectAsync(new IPEndPoint(IPAddress.Loopback, _testPort));
            await client.LoginAsync($"client{i}");
            await client.JoinRoomAsync("multitest");
            
            var clientName = $"client{i}";
            client.MessageReceived += (sender, message) => 
                receivedMessages.Add((clientName, message));
            
            _clients.Add(client);
        }
        
        // Act
        await _clients[0].SendMessageAsync("Broadcast test message", "multitest");
        await Task.Delay(200); // 等待消息传播
        
        // Assert
        receivedMessages.Should().HaveCount(clientCount); // 所有客户端都应该收到消息
        receivedMessages.All(rm => rm.message.Content == "Broadcast test message")
            .Should().BeTrue();
    }
    
    [Test]
    public async Task ConcurrentLogin_ShouldHandleMultipleSimultaneousLogins()
    {
        // Arrange
        const int clientCount = 10;
        var loginTasks = new List<Task<bool>>();
        
        // Act
        for (int i = 0; i < clientCount; i++)
        {
            var client = new ChatClient();
            await client.ConnectAsync(new IPEndPoint(IPAddress.Loopback, _testPort));
            
            var loginTask = client.LoginAsync($"concurrent{i}");
            loginTasks.Add(loginTask);
        }
        
        var results = await Task.WhenAll(loginTasks);
        
        // Assert
        results.All(r => r).Should().BeTrue(); // 所有登录都应该成功
    }
}
```

## 性能测试计划

### 1. 并发性能测试

```csharp
[TestFixture]
public class ConcurrencyPerformanceTests
{
    [Test]
    public async Task ConcurrentConnections_ShouldHandleLoad_Under100Clients()
    {
        // Arrange
        const int maxClients = 100;
        var server = new ChatServer();
        await server.StartAsync(9002);
        
        var clients = new List<ChatClient>();
        var connectionTasks = new List<Task>();
        
        // Act
        var stopwatch = Stopwatch.StartNew();
        
        for (int i = 0; i < maxClients; i++)
        {
            var client = new ChatClient();
            var task = Task.Run(async () =>
            {
                await client.ConnectAsync(new IPEndPoint(IPAddress.Loopback, 9002));
                await client.LoginAsync($"loadtest{i}");
            });
            
            connectionTasks.Add(task);
            clients.Add(client);
        }
        
        await Task.WhenAll(connectionTasks);
        stopwatch.Stop();
        
        // Assert
        stopwatch.ElapsedMilliseconds.Should().BeLessThan(5000); // 5秒内完成
        clients.All(c => c.IsConnected && c.IsAuthenticated).Should().BeTrue();
        
        // Cleanup
        await Task.WhenAll(clients.Select(c => c.DisconnectAsync()));
        await server.StopAsync();
    }
    
    [Test]
    public async Task MessageThroughput_ShouldHandle_HighVolumeMessages()
    {
        // Arrange
        const int messageCount = 1000;
        const int clientCount = 10;
        
        var server = new ChatServer();
        await server.StartAsync(9003);
        
        var clients = new List<ChatClient>();
        for (int i = 0; i < clientCount; i++)
        {
            var client = new ChatClient();
            await client.ConnectAsync(new IPEndPoint(IPAddress.Loopback, 9003));
            await client.LoginAsync($"throughput{i}");
            await client.JoinRoomAsync("throughputtest");
            clients.Add(client);
        }
        
        var receivedCount = 0;
        foreach (var client in clients)
        {
            client.MessageReceived += (sender, message) => 
                Interlocked.Increment(ref receivedCount);
        }
        
        // Act
        var stopwatch = Stopwatch.StartNew();
        
        var sendTasks = clients.Select(async (client, index) =>
        {
            for (int i = 0; i < messageCount / clientCount; i++)
            {
                await client.SendMessageAsync($"Message {i} from client {index}", "throughputtest");
            }
        });
        
        await Task.WhenAll(sendTasks);
        
        // 等待所有消息被接收
        while (receivedCount < messageCount * clientCount)
        {
            await Task.Delay(10);
        }
        
        stopwatch.Stop();
        
        // Assert
        var messagesPerSecond = messageCount * clientCount / (stopwatch.ElapsedMilliseconds / 1000.0);
        messagesPerSecond.Should().BeGreaterThan(100); // 至少100消息/秒
        
        // Cleanup
        await Task.WhenAll(clients.Select(c => c.DisconnectAsync()));
        await server.StopAsync();
    }
}
```

### 2. 内存性能测试

```csharp
[TestFixture]
public class MemoryPerformanceTests
{
    [Test]
    public async Task MemoryUsage_ShouldStayWithinLimits_UnderLoad()
    {
        // Arrange
        var server = new ChatServer();
        await server.StartAsync(9004);
        
        var initialMemory = GC.GetTotalMemory(true);
        
        // Act
        const int clientCount = 50;
        const int messagesPerClient = 100;
        
        var clients = new List<ChatClient>();
        for (int i = 0; i < clientCount; i++)
        {
            var client = new ChatClient();
            await client.ConnectAsync(new IPEndPoint(IPAddress.Loopback, 9004));
            await client.LoginAsync($"memtest{i}");
            await client.JoinRoomAsync("memorytest");
            clients.Add(client);
        }
        
        // 发送大量消息
        foreach (var client in clients)
        {
            for (int i = 0; i < messagesPerClient; i++)
            {
                await client.SendMessageAsync($"Memory test message {i}", "memorytest");
            }
        }
        
        await Task.Delay(1000); // 等待处理完成
        
        var finalMemory = GC.GetTotalMemory(true);
        var memoryIncrease = finalMemory - initialMemory;
        
        // Assert
        var memoryIncreaseInMB = memoryIncrease / (1024.0 * 1024.0);
        memoryIncreaseInMB.Should().BeLessThan(100); // 内存增长不超过100MB
        
        // Cleanup
        await Task.WhenAll(clients.Select(c => c.DisconnectAsync()));
        await server.StopAsync();
    }
}
```

## 压力测试计划

### 1. NBomber 压力测试

```csharp
public class ChatServerLoadTest
{
    public void RunLoadTest()
    {
        var scenario = Scenario.Create("chat_load_test", async context =>
        {
            var client = new ChatClient();
            
            try
            {
                // 连接
                await client.ConnectAsync(new IPEndPoint(IPAddress.Loopback, 8080));
                
                // 登录
                var username = $"loaduser{context.ScenarioInfo.ThreadId}_{context.InvocationNumber}";
                await client.LoginAsync(username);
                
                // 加入房间
                await client.JoinRoomAsync("loadtest");
                
                // 发送消息
                await client.SendMessageAsync($"Load test message {context.InvocationNumber}", "loadtest");
                
                // 等待一段时间
                await Task.Delay(100);
                
                return Response.Ok();
            }
            catch (Exception ex)
            {
                return Response.Fail(ex.Message);
            }
            finally
            {
                await client.DisconnectAsync();
            }
        })
        .WithLoadSimulations(
            Simulation.InjectPerSec(rate: 10, during: TimeSpan.FromMinutes(5)),
            Simulation.KeepConstant(copies: 50, during: TimeSpan.FromMinutes(10))
        );
        
        NBomberRunner
            .RegisterScenarios(scenario)
            .Run();
    }
}
```

## 错误恢复测试

### 1. 网络中断测试

```csharp
[TestFixture]
public class ErrorRecoveryTests
{
    [Test]
    public async Task ClientReconnection_ShouldRecover_AfterNetworkInterruption()
    {
        // Arrange
        var server = new ChatServer();
        await server.StartAsync(9005);
        
        var client = new ChatClient();
        await client.ConnectAsync(new IPEndPoint(IPAddress.Loopback, 9005));
        await client.LoginAsync("recoverytest");
        
        // Act - 模拟网络中断
        await client.SimulateNetworkInterruption();
        
        // 等待自动重连
        await Task.Delay(5000);
        
        // Assert
        client.IsConnected.Should().BeTrue();
        client.IsAuthenticated.Should().BeTrue();
        
        // 验证功能正常
        var messageReceived = false;
        client.MessageReceived += (sender, message) => messageReceived = true;
        
        await client.SendMessageAsync("Recovery test", "general");
        await Task.Delay(100);
        
        messageReceived.Should().BeTrue();
    }
    
    [Test]
    public async Task ServerRestart_ShouldHandleGracefully_WithClientNotification()
    {
        // Arrange
        var server = new ChatServer();
        await server.StartAsync(9006);
        
        var client = new ChatClient();
        await client.ConnectAsync(new IPEndPoint(IPAddress.Loopback, 9006));
        await client.LoginAsync("restarttest");
        
        var disconnectionDetected = false;
        client.Disconnected += (sender, args) => disconnectionDetected = true;
        
        // Act - 重启服务器
        await server.StopAsync();
        await Task.Delay(1000);
        await server.StartAsync(9006);
        
        // Assert
        disconnectionDetected.Should().BeTrue();
        client.IsConnected.Should().BeFalse();
    }
}
```

## 测试数据管理

### 1. 测试数据构建器

```csharp
public static class TestDataBuilder
{
    public static User CreateUser(string username = "testuser")
    {
        return new User
        {
            UserId = Guid.NewGuid().ToString(),
            Username = username,
            DisplayName = username,
            ConnectedAt = DateTime.UtcNow,
            Status = UserStatus.Online,
            IsOnline = true
        };
    }
    
    public static ChatRoom CreateRoom(string roomName = "testroom")
    {
        return new ChatRoom
        {
            RoomId = Guid.NewGuid().ToString(),
            RoomName = roomName,
            Topic = $"Test room: {roomName}",
            CreatedAt = DateTime.UtcNow,
            MaxMembers = 50,
            IsPrivate = false
        };
    }
    
    public static ChatMessage CreateChatMessage(string content = "Test message")
    {
        return new ChatMessage
        {
            MessageId = Guid.NewGuid().ToString(),
            SenderId = Guid.NewGuid().ToString(),
            SenderName = "testuser",
            Content = content,
            Timestamp = DateTime.UtcNow,
            Type = MessageType.Text,
            TargetRoomId = "testroom"
        };
    }
    
    public static ClientSession CreateClientSession()
    {
        var mockTcpClient = new Mock<TcpClient>();
        var mockNetworkStream = new Mock<NetworkStream>();
        
        return new ClientSession
        {
            SessionId = Guid.NewGuid().ToString(),
            TcpClient = mockTcpClient.Object,
            NetworkStream = mockNetworkStream.Object,
            ConnectedAt = DateTime.UtcNow,
            IsAuthenticated = false
        };
    }
}
```

## 测试执行计划

### 1. 持续集成测试
```yaml
# .github/workflows/test.yml
name: Test Suite

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 9.0.x
        
    - name: Restore dependencies
      run: dotnet restore
      
    - name: Build
      run: dotnet build --no-restore
      
    - name: Run Unit Tests
      run: dotnet test tests/EzChatSharp.UnitTests --no-build --verbosity normal
      
    - name: Run Integration Tests
      run: dotnet test tests/EzChatSharp.IntegrationTests --no-build --verbosity normal
      
    - name: Run Performance Tests
      run: dotnet test tests/EzChatSharp.PerformanceTests --no-build --verbosity normal
```

### 2. 测试报告
```bash
# 生成测试覆盖率报告
dotnet test --collect:"XPlat Code Coverage"
reportgenerator -reports:"**/coverage.cobertura.xml" -targetdir:"coveragereport" -reporttypes:Html

# 生成性能测试报告
dotnet run --project tests/EzChatSharp.PerformanceTests -c Release
```

## 测试质量标准

### 1. 覆盖率要求
- **单元测试覆盖率**: ≥ 80%
- **集成测试覆盖率**: ≥ 60%
- **关键路径覆盖率**: 100%

### 2. 性能标准
- **连接建立时间**: < 100ms
- **消息传递延迟**: < 50ms
- **并发连接数**: ≥ 100
- **消息吞吐量**: ≥ 1000 msg/s
- **内存使用**: < 500MB (100个并发用户)

### 3. 可靠性标准
- **测试通过率**: ≥ 99%
- **错误恢复时间**: < 5s
- **数据一致性**: 100%

---

*本测试计划将随着项目开发进度持续更新和完善*